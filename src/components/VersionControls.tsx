
import React, { useState, useEffect } from 'react';
import { formatVersion, Version, VersionTier, bumpVersion, applySelectedPatches } from '@/lib/versionUtils';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';
import { useDebug } from '@/contexts/DebugContext';

interface VersionControlsProps {
  version: Version;
  onVersionBump: (newVersion: Version, tier: VersionTier, description: string, isReleased?: boolean) => void;
  isModified: boolean;
  schema?: string;
  patches?: any[];
}

export const VersionControls: React.FC<VersionControlsProps> = ({ 
  version, 
  onVersionBump,
  isModified,
  schema,
  patches
}) => {
  const { debugToast, errorToast } = useDebug();
  const [description, setDescription] = useState('');
  const [selectedTier, setSelectedTier] = useState<VersionTier>('patch');
  const [editableVersion, setEditableVersion] = useState<Version>(() => ({ ...version }));
  const [isReleased, setIsReleased] = useState(false);
  
  // Update editable version when the version prop changes (e.g., from history selection)
  useEffect(() => {
    setEditableVersion({ ...version });
  }, [version.major, version.minor, version.patch]);

  // Helper function for deep object comparison
  const deepEqual = (obj1: any, obj2: any): boolean => {
    if (obj1 === obj2) return true;
    
    if (obj1 == null || obj2 == null) return false;
    if (typeof obj1 !== typeof obj2) return false;
    
    if (typeof obj1 !== 'object') return obj1 === obj2;
    
    if (Array.isArray(obj1) !== Array.isArray(obj2)) return false;
    
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    if (keys1.length !== keys2.length) return false;
    
    for (const key of keys1) {
      if (!keys2.includes(key)) return false;
      if (!deepEqual(obj1[key], obj2[key])) return false;
    }
    
    return true;
  };

  // Check if current schema is different from what would be generated by selected patches
  // Only recalculate when description or version numbers change (not on every editor keystroke)
  const hasActualChanges = React.useMemo(() => {
    debugToast('Starting commit changes check', {
      hasDescription: !!description.trim(),
      hasSchema: !!schema,
      hasPatches: !!patches,
      patchCount: patches?.length || 0,
      versionNumbers: `${editableVersion.major}.${editableVersion.minor}.${editableVersion.patch}`
    });

    // Only do the expensive comparison if user has provided a description
    // (indicating they're actually trying to commit)
    if (!description.trim()) {
      debugToast('No description provided - button will be disabled');
      return false; // No description = button disabled anyway
    }
    
    if (!schema || !patches) {
      const fallbackResult = isModified;
      debugToast('Missing schema or patches, falling back to isModified', { 
        hasSchema: !!schema, 
        hasPatches: !!patches, 
        isModified,
        result: fallbackResult
      });
      return fallbackResult;
    }
    
    try {
      const selectedPatches = patches.filter(p => p.isSelected);
      
      debugToast('Analyzing patches for changes', {
        totalPatches: patches.length,
        selectedPatches: selectedPatches.length,
        selectedPatchDescriptions: selectedPatches.map(p => p.description),
        descriptionProvided: !!description.trim(),
        versionNumbers: `${editableVersion.major}.${editableVersion.minor}.${editableVersion.patch}`
      });
      
      if (selectedPatches.length === 0) {
        // If no patches selected, any non-empty schema counts as changes
        const parsedSchema = JSON.parse(schema);
        const hasChanges = Object.keys(parsedSchema).length > 0;
        debugToast('No selected patches - checking for non-empty schema', { hasChanges, schemaKeys: Object.keys(parsedSchema) });
        return hasChanges;
      }
      
      // Parse current schema for object comparison
      const currentSchemaObj = JSON.parse(schema);
      
      // Get the expected schema from selected patches
      const expectedSchemaObj = applySelectedPatches(selectedPatches);
      
      // Do deep object comparison instead of string comparison
      const objectsEqual = deepEqual(currentSchemaObj, expectedSchemaObj);
      const hasChanges = !objectsEqual;
      
      debugToast('Deep object comparison completed', {
        currentSchemaKeys: Object.keys(currentSchemaObj),
        expectedSchemaKeys: Object.keys(expectedSchemaObj),
        objectsEqual,
        hasChanges,
        isModified,
        currentSchemaPreview: JSON.stringify(currentSchemaObj).substring(0, 100),
        expectedSchemaPreview: JSON.stringify(expectedSchemaObj).substring(0, 100),
        finalResult: hasChanges
      });
      
      return hasChanges;
    } catch (err) {
      errorToast('Error checking for actual changes', err);
      return isModified; // Fallback to basic isModified check
    }
  }, [description, editableVersion.major, editableVersion.minor, editableVersion.patch, patches, schema, isModified]);

  const handleBumpVersion = () => {
    debugToast('Commit button clicked', {
      hasActualChanges,
      hasDescription: !!description.trim(),
      description: description.trim(),
      version: `${editableVersion.major}.${editableVersion.minor}.${editableVersion.patch}`
    });

    if (!hasActualChanges) {
      toast.warning('No changes to commit');
      debugToast('Commit blocked: No actual changes detected');
      return;
    }
    
    if (!description.trim()) {
      toast.warning('Please provide a description for your changes');
      debugToast('Commit blocked: No description provided');
      return;
    }
    
    onVersionBump(editableVersion, selectedTier, description, isReleased);
    setDescription('');
    setIsReleased(false);
    toast.success(`Version ${isReleased ? 'released' : 'created'}: ${formatVersion(editableVersion)}`);
  };

  const handleVersionChange = (part: keyof Version, value: string) => {
    const numValue = parseInt(value, 10);
    if (!isNaN(numValue) && numValue >= 0) {
      setEditableVersion(prev => ({
        ...prev,
        [part]: numValue
      }));
      setSelectedTier(part);
    }
  };
  
  return (
    <div className="border-t border-slate-200 p-3 bg-slate-50 space-y-2">
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-medium text-slate-700">Current Version</h3>
        {hasActualChanges && <span className="text-xs px-2 py-1 bg-amber-100 text-amber-800 rounded-full">Modified</span>}
      </div>
      
      <div className="flex flex-col gap-2">
        <div className="flex gap-2 items-center">
          <span className="text-xs text-slate-500 w-20">Version:</span>
          <div className="flex gap-2">
            {/* Major Version */}
            <div className="flex items-center">
              <Input
                type="number"
                value={editableVersion.major}
                onChange={(e) => handleVersionChange('major', e.target.value)}
                className={`w-16 h-8 text-center text-xs ${selectedTier === 'major' ? 'border-blue-400 ring-1 ring-blue-400' : ''}`}
                min="0"
              />
              <span className="text-xs font-bold mx-1">.</span>
            </div>
            
            {/* Minor Version */}
            <div className="flex items-center">
              <Input
                type="number"
                value={editableVersion.minor}
                onChange={(e) => handleVersionChange('minor', e.target.value)}
                className={`w-16 h-8 text-center text-xs ${selectedTier === 'minor' ? 'border-blue-400 ring-1 ring-blue-400' : ''}`}
                min="0"
              />
              <span className="text-xs font-bold mx-1">.</span>
            </div>
            
            {/* Patch Version */}
            <div className="flex items-center">
              <Input
                type="number"
                value={editableVersion.patch}
                onChange={(e) => handleVersionChange('patch', e.target.value)}
                className={`w-16 h-8 text-center text-xs ${selectedTier === 'patch' ? 'border-blue-400 ring-1 ring-blue-400' : ''}`}
                min="0"
              />
            </div>
          </div>
        </div>
        
        <div className="flex gap-2 items-center">
          <span className="text-xs text-slate-500 w-20">Description:</span>
          <input
            type="text"
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            placeholder="Describe your changes"
            className="flex-1 text-xs p-1 border border-slate-300 rounded"
          />
        </div>
        
        <div className="flex gap-2 items-center">
          <span className="text-xs text-slate-500 w-20"></span>
          <label className="flex items-center gap-2 text-xs">
            <input
              type="checkbox"
              checked={isReleased}
              onChange={(e) => setIsReleased(e.target.checked)}
              className="w-4 h-4"
            />
            Mark as Released (stores full document)
          </label>
        </div>
        
        <Button 
          size="sm" 
          variant="outline" 
          disabled={!hasActualChanges || !description.trim()}
          onClick={handleBumpVersion}
          className="ml-auto text-xs"
          title={!hasActualChanges ? "No changes to commit" : !description.trim() ? "Please enter a description" : ""}
        >
          Commit Changes {hasActualChanges ? '✓' : '✗'}
        </Button>
      </div>
    </div>
  );
};
