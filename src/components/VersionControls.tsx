
import React, { useState, useEffect } from 'react';
import { formatVersion, Version, VersionTier, bumpVersion, applySelectedPatches } from '@/lib/versionUtils';
import { DocumentVersionComparison } from '@/lib/importVersionUtils';
import { ImportVersionDialog } from './ImportVersionDialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';
import { useDebug } from '@/contexts/DebugContext';
import { Download } from 'lucide-react';

interface VersionControlsProps {
  version: Version;
  userRole?: 'owner' | 'editor' | 'viewer' | null;
  onVersionBump: (newVersion: Version, tier: VersionTier, description: string, isReleased?: boolean, autoVersion?: boolean) => Promise<string | null>;
  isModified: boolean;
  schema?: string;
  patches?: any[];
  onImportVersion?: (importedSchema: any, comparison: DocumentVersionComparison, sourceDocumentName: string) => void;
  documentId?: string;
  currentFileType?: string;
  suggestedVersion?: Version | null;
  onVersionCreated?: () => void; // NEW: callback after successful commit
}

export const VersionControls: React.FC<VersionControlsProps> = ({ 
  version, 
  userRole,
  onVersionBump,
  isModified,
  schema,
  patches,
  onImportVersion,
  documentId,
  currentFileType,
  suggestedVersion,
  onVersionCreated
}) => {
  const { debugToast, errorToast } = useDebug();
  const [description, setDescription] = useState('');
  const [selectedTier, setSelectedTier] = useState<VersionTier>('patch');
  const [editableVersion, setEditableVersion] = useState<Version>(() => ({ ...version }));
  const [isReleased, setIsReleased] = useState(false);
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const [autoVersion, setAutoVersion] = useState(true);
  
  // Calculate next version (patch bump by default for auto-versioning preview)
  const nextVersion = React.useMemo((): Version => {
    return {
      major: version.major,
      minor: version.minor,
      patch: version.patch + 1
    };
  }, [version.major, version.minor, version.patch]);
  
  // Update editable version when the version prop changes (e.g., from history selection)
  // When auto-versioning, show next version; when manual, show current version
  useEffect(() => {
    if (autoVersion) {
      setEditableVersion({ ...nextVersion });
    } else {
      setEditableVersion({ ...version });
    }
  }, [version.major, version.minor, version.patch, autoVersion]);

  // Apply suggested version when it changes (for validation errors)
  useEffect(() => {
    if (suggestedVersion) {
      setEditableVersion({ ...suggestedVersion });
      toast.info('Version number updated', {
        description: `Suggested version ${formatVersion(suggestedVersion)} has been set. Please try again.`,
      });
    }
  }, [suggestedVersion]);

  // Helper function for deep object comparison
  const deepEqual = (obj1: any, obj2: any): boolean => {
    if (obj1 === obj2) return true;
    
    if (obj1 == null || obj2 == null) return false;
    if (typeof obj1 !== typeof obj2) return false;
    
    if (typeof obj1 !== 'object') return obj1 === obj2;
    
    if (Array.isArray(obj1) !== Array.isArray(obj2)) return false;
    
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    
    if (keys1.length !== keys2.length) return false;
    
    for (const key of keys1) {
      if (!keys2.includes(key)) return false;
      if (!deepEqual(obj1[key], obj2[key])) return false;
    }
    
    return true;
  };

  // Check if current schema is different from what would be generated by selected patches
  // Only recalculate when description or version numbers change (not on every editor keystroke)
  const hasActualChanges = React.useMemo(() => {
    // Only log when description is provided to reduce noise
    if (description.trim()) {
      debugToast('Commit check triggered', {
        trigger: 'description/version change',
        hasDescription: !!description.trim(),
        hasSchema: !!schema,
        hasPatches: !!patches,
        patchCount: patches?.length || 0,
        versionNumbers: `${editableVersion.major}.${editableVersion.minor}.${editableVersion.patch}`
      });
    }

    // Only do the expensive comparison if user has provided a description
    // (indicating they're actually trying to commit)
    if (!description.trim()) {
      return false; // No description = button disabled anyway
    }
    
    if (!schema || !patches) {
      const fallbackResult = isModified;
      debugToast('Missing schema or patches, falling back to isModified', { 
        hasSchema: !!schema, 
        hasPatches: !!patches, 
        isModified,
        result: fallbackResult
      });
      return fallbackResult;
    }
    
    try {
      const selectedPatches = patches.filter(p => p.isSelected);
      
      // Only log detailed analysis when description is provided
      if (description.trim()) {
        debugToast('Analyzing patches', {
          total: patches.length,
          selected: selectedPatches.length,
          descriptions: selectedPatches.map(p => p.description)
        });
      }
      
      if (selectedPatches.length === 0) {
        // If no patches selected, any non-empty schema counts as changes
        const parsedSchema = JSON.parse(schema);
        const hasChanges = Object.keys(parsedSchema).length > 0;
        if (description.trim()) {
          debugToast('No patches selected - checking schema', { hasChanges, keys: Object.keys(parsedSchema).length });
        }
        return hasChanges;
      }
      
      // Parse current schema for object comparison
      const currentSchemaObj = JSON.parse(schema);
      
      // Get the expected schema from selected patches
      const expectedSchemaObj = applySelectedPatches(selectedPatches);
      
      // Do deep object comparison instead of string comparison
      const objectsEqual = deepEqual(currentSchemaObj, expectedSchemaObj);
      const hasChanges = !objectsEqual;
      
      // Only log the final result when there's a description
      if (description.trim()) {
        debugToast('Comparison result', {
          hasChanges,
          objectsEqual,
          currentKeys: Object.keys(currentSchemaObj).length,
          expectedKeys: Object.keys(expectedSchemaObj).length
        });
      }
      
      return hasChanges;
    } catch (err) {
      errorToast('Commit check failed', err);
      return isModified; // Fallback to basic isModified check
    }
  }, [description, editableVersion.major, editableVersion.minor, editableVersion.patch, patches, schema, isModified]);

  const handleBumpVersion = async () => {
    debugToast('Commit clicked', {
      hasChanges: hasActualChanges,
      hasDescription: !!description.trim(),
      version: `${editableVersion.major}.${editableVersion.minor}.${editableVersion.patch}`
    });

    if (!hasActualChanges) {
      toast.warning('No changes to commit');
      return;
    }
    
    if (!description.trim()) {
      toast.warning('Please provide a description for your changes');
      return;
    }
    
    const result = await onVersionBump(editableVersion, selectedTier, description, isReleased, autoVersion);
    setDescription('');
    setIsReleased(false);
    
    // Trigger refresh after successful commit
    if (result !== null) {
      onVersionCreated?.();
    }
    
    if (!autoVersion) {
      toast.success(`Version ${isReleased ? 'released' : 'created'}: ${formatVersion(editableVersion)}`);
    } else {
      toast.success(`Version ${isReleased ? 'released' : 'created'} (auto-versioned)`);
    }
  };

  const handleVersionChange = (part: keyof Version, value: string) => {
    const numValue = parseInt(value, 10);
    if (!isNaN(numValue) && numValue >= 0) {
      setEditableVersion(prev => ({
        ...prev,
        [part]: numValue
      }));
      setSelectedTier(part);
    }
  };

  const handleImportVersion = (importedSchema: any, comparison: DocumentVersionComparison, sourceDocumentName: string) => {
    onImportVersion?.(importedSchema, comparison, sourceDocumentName);
    setImportDialogOpen(false);
  };

  const currentSchemaObj = React.useMemo(() => {
    try {
      return schema ? JSON.parse(schema) : {};
    } catch {
      return {};
    }
  }, [schema]);
  
  return (
    <div className="border-t border-slate-200 p-3 bg-slate-50 space-y-2">
      <div className="flex items-center justify-between">
        <h3 className="text-sm font-medium text-slate-700">Commit Version</h3>
        <div className="flex items-center gap-2">
          {onImportVersion && documentId && currentFileType && (
            <Button
              variant="outline"
              size="sm"
              onClick={() => setImportDialogOpen(true)}
              className="flex items-center gap-1 text-xs"
            >
              <Download className="h-3 w-3" />
              Import
            </Button>
          )}
          {hasActualChanges && <span className="text-xs px-2 py-1 bg-amber-100 text-amber-800 rounded-full">Modified</span>}
        </div>
      </div>
      
      <div className="flex flex-col gap-2">
        <div className="flex gap-2 items-center">
          <span className="text-xs text-slate-500 w-20">Version:</span>
          <div className="flex gap-2 items-center">
            <label className="flex items-center gap-1.5 text-xs mr-2">
              <input
                type="checkbox"
                checked={autoVersion}
                onChange={(e) => setAutoVersion(e.target.checked)}
                className="w-3.5 h-3.5"
              />
              Auto
            </label>
            {/* Major Version */}
            <div className="flex items-center">
              <Input
                type="number"
                value={editableVersion.major}
                onChange={(e) => handleVersionChange('major', e.target.value)}
                className={`w-16 h-8 text-center text-xs ${selectedTier === 'major' ? 'border-blue-400 ring-1 ring-blue-400' : ''} ${autoVersion ? 'opacity-50' : ''}`}
                min="0"
                disabled={autoVersion}
              />
              <span className="text-xs font-bold mx-1">.</span>
            </div>
            
            {/* Minor Version */}
            <div className="flex items-center">
              <Input
                type="number"
                value={editableVersion.minor}
                onChange={(e) => handleVersionChange('minor', e.target.value)}
                className={`w-16 h-8 text-center text-xs ${selectedTier === 'minor' ? 'border-blue-400 ring-1 ring-blue-400' : ''} ${autoVersion ? 'opacity-50' : ''}`}
                min="0"
                disabled={autoVersion}
              />
              <span className="text-xs font-bold mx-1">.</span>
            </div>
            
            {/* Patch Version */}
            <div className="flex items-center">
              <Input
                type="number"
                value={editableVersion.patch}
                onChange={(e) => handleVersionChange('patch', e.target.value)}
                className={`w-16 h-8 text-center text-xs ${selectedTier === 'patch' ? 'border-blue-400 ring-1 ring-blue-400' : ''} ${autoVersion ? 'opacity-50' : ''}`}
                min="0"
                disabled={autoVersion}
              />
            </div>
          </div>
        </div>
        
        <div className="flex gap-2 items-center">
          <span className="text-xs text-slate-500 w-20">Description:</span>
          <input
            type="text"
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            placeholder="Describe your changes"
            className="flex-1 text-xs p-1 border border-slate-300 rounded"
          />
        </div>
        
        <div className="flex gap-2 items-center">
          <span className="text-xs text-slate-500 w-20"></span>
          <label className="flex items-center gap-2 text-xs">
            <input
              type="checkbox"
              checked={isReleased}
              onChange={(e) => setIsReleased(e.target.checked)}
              className="w-4 h-4"
            />
            Mark as Released (stores full document)
          </label>
        </div>
        
        <Button 
          size="sm" 
          variant="outline" 
          disabled={!hasActualChanges || !description.trim()}
          onClick={handleBumpVersion}
          className="ml-auto text-xs"
          title={!hasActualChanges ? "No changes to commit" : !description.trim() ? "Please enter a description" : ""}
        >
          Commit Changes {hasActualChanges ? '✓' : '✗'}
        </Button>
      </div>
      
      {/* Import Version Dialog */}
      {onImportVersion && documentId && currentFileType && (
        <ImportVersionDialog
          isOpen={importDialogOpen}
          onOpenChange={setImportDialogOpen}
          currentSchema={currentSchemaObj}
          onImportConfirm={handleImportVersion}
          currentDocumentId={documentId}
          currentFileType={currentFileType}
        />
      )}
    </div>
  );
};
